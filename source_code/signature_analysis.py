import os
import logging
import ast
import random

import pandas as pd

type = 'ransom' # malicious type

def get_sequences(path):
    file = open(path, 'r')
    frequent_sequences = []
    for line in file:
        if line.startswith("min_frequency:") or line.startswith("number_sequences:"):
            continue
        frequent_sequences=ast.literal_eval(line)

    return frequent_sequences

def get_sequence_with_type(type='benign',flag=0):
    cwd = os.getcwd()
    
    most_frequent_sequences = get_sequences(f'./sequences/results/most_frequent_sequences_{type}.txt')
    less_frequent_sequences = get_sequences(f'./sequences/results/less_frequent_sequences_{type}.txt')
    all = most_frequent_sequences + less_frequent_sequences[:500]

    sequences = {}
    for sequence in all:
        sequences[str(sequence[:-1])] = flag
    return sequences

def get_specific_number_of_signatures(signatures,all_signatures,flag,number):
    for key, value in all_signatures.items():
        if value == flag:
            signatures[key] = value
        
        if len(signatures) == number:
            break

def get_signatures():
    benign_sequences = get_sequence_with_type(type='benign')
    malicious_sequences = get_sequence_with_type(type=type,flag=1)

    benign_keys = set(benign_sequences.keys())
    malicious_keys = set(malicious_sequences.keys())

    unique_keys = set(benign_keys) ^ set(malicious_keys)
    print(list(unique_keys)[0:10])

    all_signatures = {}

    for key in unique_keys:
        if key in benign_sequences:
            all_signatures[key] = benign_sequences[key]
        else:
            all_signatures[key] = malicious_sequences[key]

    signatures = {}
    get_specific_number_of_signatures(signatures,all_signatures,flag=0,number=50) # Specify number of elements per flag (0-50)
    get_specific_number_of_signatures(signatures,all_signatures,flag=1,number=100) # The number must be the total length of the list (51-100)

    return signatures

def isSublist(a,b):
    for index in range(len(b)-len(a)+1):
        if b[index:index+len(a)] == a:
            return True
    return False

def identify_element_class(signatures,type='benign',flag=0):
    file = open(f'./sequences/results/api_sequences_{type}.txt', 'r')

    system_calls = []
    for line in file:
        calls = line.split(sep=',')
        system_calls.append(calls)

    predictions = []
    for system_call in system_calls:
        for key,value in list(signatures.items()):
            signature_as_list = ast.literal_eval(key)
            predicted = 0
            if isSublist(signature_as_list,system_call):
                predicted = value
                break
        predictions.append([predicted, flag])

    return predictions

def calculate_performance_metrics(benign_predictions, malicious_predictions):
    predicted_positive = 0
    predicted_negative = 0

    fp = 0
    fn = 0

    tn = 0
    tp = 0 
    
    all_predictions = benign_predictions + malicious_predictions

    for prediction in all_predictions:
        if prediction[0] == 0:
            predicted_negative+= 1
        else:
            predicted_positive+=1

        if prediction[0] == 0 and prediction[0] != prediction[-1]:
            fn+=1
        elif prediction[0] == 1 and prediction[0] != prediction[-1]:
            fp+=1

        if prediction[0] == 0 and prediction[0] == prediction[-1]:
            tn+=1
        elif prediction[0] == 1 and prediction[0] == prediction[-1]:
            tp+=1

    n = len(benign_predictions)
    p = len(malicious_predictions) 

    print(f'p: {p}')
    print(f'n: {n}')
    print(f'tn: {tn}')
    print(f'tp: {tp}')
    print(f'fp: {fp}')
    print(f'fn: {fn}')
    print(f'predicted negative: {predicted_negative}')
    print(f'predicted positive: {predicted_positive}')

    precision = 0
    if tp !=0 and fp !=0:
        precision = tp/(tp+fp)
    accuracy = (tp+tn)/(p+n)
    f1_score = (2*tp)/((2*tp)+fp+fn)
            
    print(f'precision: {str(precision).replace(".", ",")}')
    print(f'accuracy: {str(accuracy).replace(".", ",")}')
    print(f'f1_score: {str(f1_score).replace(".", ",")}')


signatures = get_signatures()
benign_predictions = identify_element_class(signatures)
malicious_predictions = identify_element_class(signatures,type=type,flag=1)

calculate_performance_metrics(benign_predictions, malicious_predictions)